# CLIENT

## 1. Pravljenje Server Address 
        -> sockaddr_in serverAddress;

## 2. Duzina Server Address
        -> int sockAddrLen = sizeof(serverAddress); 

## 3. Inicijalizacija buffera za smestanje poruke
        -> char dataBuffer[BUFFER_SIZE];
    
## 4. Inicijalizacija WSA
        -> WSADATA wsaData;
    
## 5. WSAStartup(I provera da li je uspelo posle toga)
        -> int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
            if (iResult != 0)
            {
                printf("WSAStartup failed with error: %d\n", iResult);
                return 1;
            }

## 6. Inicijalizacija Server Address
        -> memset((char*)&serverAddress, 0, sizeof(serverAddress));
    
## 7. Popunjavanje Server Address(family,ip,port)
        -> serverAddress.sinFamily = AF_INET;
            serverAddress.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            serverAddress.sin_port = htons((unsigned short)portNum);

## 8. Pravljenje ConnectSocketa (I provera jel napravljen)
        ->     SOCKET  connectSocket = socket(AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP);

                if (connectSocket == INVALID_SOCKET)
                {
                    printf("socket failed with error: %ld\n", WSAGetLastError());
                    WSACleanup();
                    return 1;
                }
    
## 9. Povezivanje i provera povezivanja connectsocketa
        -> if (connect(connectSocket, (SOCKADDR*)&serverAddress, sizeof(serverAddress)) == SOCKET_ERROR)
            {
                printf("Unable to connect to server.\n");
                closesocket(connectSocket);
                WSACleanup();
                return 1;
            }

## 10. Obicno do while i tu idu sve funkcionalnosti

## 11. Gasenje soketa 
        -> iResult = shutdown(connectSocket, SD_BOTH);

## 12. Zatvaranje napravljenog soketa(I provera jel uspesno izvrseno zatvaranje)

## 13. WSACleanup()


# SERVER

## 1. Pravljenje Listen Socketa 

## 2. Pravljenje Accept Socketa (Koliko treba razlicitih)

## 3. Inicijalizacija buffera za smestanje poruke
        -> char dataBuffer[BUFFER_SIZE];
    
## 4. Inicijalizacija WSA
        -> WSADATA wsaData;
    
## 5. WSAStartup(I provera da li je uspelo posle toga)
        -> int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
            if (iResult != 0)
            {
                printf("WSAStartup failed with error: %d\n", iResult);
                return 1;
            }

## 6. Inicijalizacija Server Address
         ->  sockaddr_in serverAddress;
            memset((char*)&serverAddress, 0, sizeof(serverAddress));
    
## 7. Popunjavanje Server Address(family,ip,port)
        -> serverAddress.sinFamily = AF_INET;
            serverAddress.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            serverAddress.sin_port = htons((unsigned short)portNum);

## 8. Pravljenje Listen Socketa (I provera jel napravljen)
        ->     SOCKET listenSocket = socket(AF_INET,      // IPv4 address famly
                    SOCK_DGRAM,                            // Datagram socket
                    IPPROTO_UDP);                          // UDP protocol

                if (listenSocket == INVALID_SOCKET)
                {
                    printf("Creating socket failed with error: %d\n", WSAGetLastError());
                    WSACleanup();
                    return 1;
                }

## 9. Bindovanje soketa(Koliko god ih imamo) i provera da li je bindovano
    -> int iResult = bind(serverSocket, (SOCKADDR*)&serverAddress, sizeof(serverAddress));
        if (iResult == SOCKET_ERROR)
        {
            printf("Socket bind failed with error: %d\n", WSAGetLastError());
            closesocket(serverSocket);
            WSACleanup();
            return 1;
        }

## 10. Stavljanje na listen socket 
    -> iResult = listen(listenSocket, SOMAXCONN);
        if (iResult == SOCKET_ERROR)
        {
            printf("listen failed with error: %d\n", WSAGetLastError());
            closesocket(listenSocket);
            WSACleanup();
            return 1;
        }

## 11. Ispis da server krece sa radom

## 12. Obicno do while 
    -> Unutar prvog do while ide (Ne mora uvek do while ovo je primer) :
            -> Pravljenje Clientaddress 
            -> accept prihvatajuce sockete
            -> Stavljanje u neblokirajuci
     -> Unutar drugog do while ide funkcionalnost (Ne mora uvek do while ovo je primer)   

    -> Jedina razlika kod pooling modela je sto proveravamo da li je doslo do SOCKET_ERRORA ako jeste sa WSAGetLastError proveravamo da li je WSAEWOULDBLOCK ako jeste onda sleepujemo na odredjeno vreme i obicno ili kroz dva do while ili kroz for napravimo da se recv i ta provera gresaka desava iterativno

## 14. Zatvaranje svih otvorenih Socketa

## 15. WSACleanup